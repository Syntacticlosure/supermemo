Date, Element No, Used interval, SM16 Interval (new), SM17 Interval (new), SM17/SM16 Interval ratio, R (SM16), R (SM17)(exp), R (SM17), Grade, Success, abs RM16, abs RM17 (expected), abs RM17 (predicted), abs R-Metric, sqr R-Metric, Title,
5月 12 2021 10:27:36,4,2,5,3,0.66,0.951,0.948,0.948,5,1,0.0486,0.0524,0.0524,-0.0038,-0.0004,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
5月 12 2021 10:27:41,2,3,9,3,0.36,0.936,0.902,0.902,5,1,0.0641,0.0977,0.0977,-0.0336,-0.0054,假设背包问题中的物品有A_B_C，容量是4，那么所需要建立的动态规划表（dynamic programming table）的两列索引是？
5月 12 2021 10:27:49,3,2,5,13,2.62,0.961,0.983,0.983,5,1,0.039,0.0167,0.0167,0.0223,0.0012,page rank算法中，如果用N表示node的数量，d代表用户从此页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
5月 16 2021 10:47:06,4,4,13,23,1.81,0.951,0.986,0.986,5,1,0.0489,0.0141,0.0141,0.0348,0.0022,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
May 17 2021 11:47:05,2,5,16,29,1.81,0.962,0.984,0.986,5,1,0.0383,0.0162,0.0137,0.0245,0.0013,假设背包问题中的物品有A_B_C，容量是4，那么所需要建立的动态规划表（dynamic programming table）的两列索引是？
May 25 2021 12:19:13,3,13,41,36,0.89,0.839,0.955,0.958,5,1,0.161,0.0452,0.042,0.1191,0.0242,page rank算法中，如果用N表示node的数量，d代表用户从某页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
Jun 08 2021 09:21:13,4,23,79,39,0.49,0.888,0.942,0.945,5,1,0.112,0.0584,0.0553,0.0567,0.0095,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
6月 15 2021 11:36:46,2,29,104,67,0.65,0.893,0.935,0.957,5,1,0.1072,0.0649,0.0431,0.0641,0.0096,假设背包问题中的物品有A_B_C，容量是4，那么所需要建立的动态规划表（dynamic programming table）的两列索引是？
Jun 30 2021 09:25:37,3,36,120,44,0.37,0.941,0.916,0.952,5,1,0.059,0.0844,0.0478,0.0112,0.0012,page rank算法中，如果用N表示node的数量，d代表用户从某页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
7月 17 2021 11:29:52,4,39,142,84,0.59,0.968,0.934,0.967,5,1,0.0324,0.0656,0.0333,-0.0009,-0.0001,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
Aug 13 2021 10:42:51,3,44,158,76,0.48,0.976,0.936,0.971,5,1,0.0241,0.0638,0.0292,-0.0051,-0.0003,page rank算法中，如果用N表示node的数量，d代表用户从某页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
Aug 21 2021 13:30:48,2,67,227,129,0.57,0.952,0.912,0.961,5,1,0.0477,0.0878,0.0391,0.0087,0.0008,假设背包问题中的物品有A_B_C，容量是4，那么所需要建立的动态规划表（dynamic programming table）的两列索引是？
Aug 23 2021 09:43:18,11,22,75,42,0.56,0.67,0.932,0.959,5,1,0.3296,0.0676,0.0405,0.289,0.107,如果a和b是正整数且a > b，那么简述计算gcd(a_b)的欧几里得算法。
Aug 23 2021 09:44:23,7,31,101,76,0.75,0.594,0.907,0.954,5,1,0.406,0.0926,0.0459,0.3601,0.1627,算法中维护一段数组上的闭区间[lo_hi]，并通过while循环不断迭代修改该区间的范围: while( [.] ) { . }
Aug 24 2021 11:33:47,6,32,106,47,0.45,0.605,0.904,0.958,5,1,0.3945,0.0957,0.0424,0.3522,0.1538,写出计算正整数lo和正整数hi (lo <= hi) 的中间值整数mid的表达式，并且不能有溢出风险。
Aug 29 2021 11:36:43,16,22,76,70,0.92,0.723,0.933,0.972,5,1,0.277,0.0665,0.0277,0.2494,0.076,java中某个类如果想要用foreach遍历它，那么这个类需要满足什么条件？
Aug 31 2021 10:57:01,55,1,3,25,8.32,0.986,0.998,0.996,5,1,0.0139,0.0018,0.0039,0.0099,0.0002,上图为快速排序对数组进行分割，v为基准值。 简述算法中i和j所起到的作用：[.]
Aug 31 2021 10:57:12,18,24,83,63,0.76,0.727,0.928,0.975,5,1,0.273,0.0723,0.0255,0.2476,0.0739,用数组实现循环队列的经典做法：维护两个指针： 1.front指针指向队列中第一个元素 2.tail指针指向 [.] 。
Sep 01 2021 11:00:12,22,25,86,70,0.82,0.728,0.925,0.975,5,1,0.2722,0.0752,0.0247,0.2475,0.0735,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。  则表示队列中元素数量的表达式为 [.] 。
Sep 03 2021 11:14:02,19,27,93,61,0.66,0.719,0.919,0.975,5,1,0.2807,0.0811,0.0247,0.256,0.0782,用数组实现循环队列的经典做法：如果数组的长度为10，那么实际队列的最大长度为 [.] 。
Sep 03 2021 11:16:15,13,28,97,64,0.66,0.719,0.916,0.976,5,1,0.2806,0.084,0.0241,0.2565,0.0782,java中int类型和Integer类型的区别是？
Sep 03 2021 11:25:56,9,34,7,1,0.14,0.661,0.898,0.973,2,0,0.6613,0.8985,0.9732,-0.3119,-0.5098,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Sep 03 2021 11:26:02,8,34,117,42,0.36,0.687,0.539,0.539,5,1,0.3126,0.4606,0.4606,-0.148,-0.1144,将十进制数x转换为2进制字符串，对x不断进行除2操作，获得的余数为r1_r2_r3_._rk，则最终的转换结果为？
Sep 04 2021 11:37:37,10,34,117,30,0.26,0.695,0.603,0.603,5,1,0.3052,0.3967,0.3967,-0.0914,-0.0642,brute force算法是什么？
Sep 04 2021 11:40:21,9,1,2,2,0.84,0.989,0.899,0.899,5,1,0.0106,0.1009,0.1009,-0.0903,-0.0101,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Sep 06 2021 11:35:19,14,31,107,52,0.48,0.762,0.696,0.696,5,1,0.2385,0.3039,0.3039,-0.0654,-0.0355,java中为了将基础值类型作为泛型参数时的便利性（自动将基础类型和其对应的引用类型转换），提供了什么样的功能？
Sep 06 2021 11:36:02,9,2,5,4,0.76,0.925,0.932,0.932,5,1,0.0751,0.0681,0.0681,0.007,0.001,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Sep 07 2021 10:24:50,12,37,128,56,0.43,0.727,0.711,0.711,5,1,0.2734,0.2889,0.2889,-0.0155,-0.0087,洗牌算法：将长度为N的数组arr打乱：. for(int i=0;i<N-1;i++){.    将数组arr中第i个元素和[.]交换。. }
9月 09 2021 15:44:24,15,33,114,24,0.21,0.756,0.802,0.802,5,1,0.2443,0.1982,0.1982,0.0461,0.0204,在java的类定义public class FixedCapacityStack<Item>中. a = new Item[cap];. 需要被写成. a = (Item[]) new Object[cap];. 的原因是？
Sep 10 2021 11:47:06,9,4,13,8,0.58,0.951,0.914,0.914,5,1,0.0489,0.0865,0.0865,-0.0375,-0.0051,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Sep 18 2021 09:28:38,29,24,83,50,0.6,0.818,0.888,0.977,5,1,0.1818,0.1121,0.0233,0.1585,0.0325,简述算法复杂度符号~的定义： f(N) ~ g(N)，即 [.] 。
Sep 18 2021 09:28:42,9,8,28,19,0.69,0.96,0.909,0.909,5,1,0.0405,0.0911,0.0911,-0.0507,-0.0067,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Sep 18 2021 09:28:46,21,42,151,56,0.37,0.708,0.841,0.97,5,1,0.2925,0.1591,0.0301,0.2624,0.0846,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。 . 则判断队列是否为满的表达式为 [.] 。
9月 19 2021 09:53:38,72,1,3,26,8.56,0.992,0.998,0.996,5,1,0.0081,0.0016,0.0045,0.0036,0.0000,证明：任何基于比较的排序算法至少会进行N lgN次比较。 假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 [.]则比较的次数大约是 该比较树的高度。
9月 19 2021 09:54:07,44,1,3,25,8.17,0.992,0.998,0.995,5,1,0.008,0.0017,0.0045,0.0035,0.0000,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
9月 19 2021 09:54:13,73,1,3,25,8.5,0.992,0.998,0.995,5,1,0.0079,0.0016,0.0045,0.0034,0.0000,证明：任何基于比较的排序算法至少会进行N lgN次比较。  假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 N! 则比较的次数大约是 [.]。
9月 19 2021 09:54:42,57,20,72,80,1.11,0.855,0.939,0.987,5,1,0.145,0.061,0.0127,0.1323,0.0209,归并排序中对 [lo.hi] 的部分进行分割为两部分后分别排序，如果mid = lo + (hi - lo)/2_ 那么分割为哪两部分（尽量使得两部分一样长）？
9月 19 2021 09:55:11,68,1,3,32,10.61,0.992,0.998,0.995,5,1,0.0077,0.0017,0.0046,0.0032,0.0000,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Sep 20 2021 05:29:42,30,26,94,89,0.95,0.819,0.922,0.986,5,1,0.1808,0.0775,0.0142,0.1666,0.0325,简述算法复杂度符号big O的定义 (用常数c，N_0定义）：f(N) = O(g(N))
Sep 20 2021 05:32:07,45,23,83,114,1.38,0.84,0.93,0.987,5,1,0.1603,0.0701,0.013,0.1473,0.0255,选择排序的时间复杂度是？ (big O)
Sep 21 2021 11:12:41,59,22,79,65,0.83,0.847,0.933,0.988,5,1,0.1526,0.0671,0.0124,0.1402,0.0231,归并排序的合并操作在什么情况下是可以被省略的。
Sep 21 2021 11:13:00,32,27,97,88,0.91,0.818,0.919,0.986,5,1,0.1824,0.0811,0.0137,0.1687,0.0331,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
Sep 21 2021 11:13:34,20,45,12,1,0.08,0.717,0.868,0.981,2,0,0.7168,0.8676,0.9808,-0.264,-0.4482,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
Sep 21 2021 11:15:46,37,26,94,29,0.31,0.826,0.781,0.781,5,1,0.1737,0.2187,0.2187,-0.045,-0.0176,union-find algorithm(并查集算法）中weighted quick union相比quick union在union方法中的区别是？
9月 24 2021 13:50:05,69,6,17,18,1.06,0.957,0.952,0.952,5,1,0.0428,0.0479,0.0479,-0.0051,-0.0005,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
9月 24 2021 13:50:25,38,29,104,51,0.49,0.811,0.788,0.788,5,1,0.1892,0.212,0.212,-0.0228,-0.0092,union-find algorithm(并查集算法）中weighted quick union中使用路径压缩，就是说？
9月 24 2021 13:50:45,27,30,108,36,0.33,0.806,0.802,0.802,5,1,0.1938,0.1978,0.1978,-0.0039,-0.0015,2-sum：给一个数组，找到其中所有和为0的序对，简述在线性时间内完成的思路。
9月 24 2021 13:51:03,53,25,11,1,0.09,0.819,0.846,0.846,2,0,0.8185,0.8464,0.8464,-0.0279,-0.0464,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
9月 24 2021 13:57:16,20,3,6,5,0.86,0.972,0.72,0.737,5,1,0.0282,0.2797,0.263,-0.2349,-0.0684,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
9月 24 2021 13:57:22,23,48,173,68,0.39,0.693,0.543,0.543,5,1,0.3067,0.4566,0.4566,-0.1499,-0.1144,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。  则tail指针的后一个位置的表达式为 [.] 。
9月 24 2021 13:58:35,63,25,90,31,0.34,0.832,0.751,0.751,5,1,0.1682,0.2487,0.2487,-0.0805,-0.0336,快速排序可以通过在排序比较小的数组的时候进行 [.] 来提升速度。
Sep 26 2021 21:45:24,53,2,4,6,1.46,0.982,0.782,0.86,5,1,0.0175,0.2176,0.1403,-0.1228,-0.0194,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Sep 26 2021 21:45:39,51,27,97,27,0.27,0.827,0.745,0.745,5,1,0.1734,0.2545,0.2545,-0.0812,-0.0347,归并排序（是/不是）原地排序算法。
9月 27 2021 12:36:12,62,28,101,30,0.29,0.825,0.763,0.763,5,1,0.1745,0.2375,0.2375,-0.063,-0.0259,为了防止快速排序最坏的情况发生，在排序前需要进行 [.] 。
Sep 28 2021 12:46:28,34,33,119,25,0.21,0.799,0.743,0.743,5,1,0.2014,0.2572,0.2572,-0.0557,-0.0256,扔鸡蛋问题：现在有有限个鸡蛋，求鸡蛋不会碎的最大楼层，简述解题思路。
Sep 28 2021 12:47:06,31,34,122,40,0.33,0.794,0.756,0.756,5,1,0.206,0.2436,0.2436,-0.0376,-0.0169,简述算法复杂度符号small o的定义（利用极限）： f(N) = o(g(N))
Sep 29 2021 16:00:10,25,43,155,38,0.25,0.748,0.721,0.721,5,1,0.252,0.2789,0.2789,-0.0269,-0.0143,单向链表如何在O(1)内实现末尾插入操作。
Sep 29 2021 16:00:17,20,5,14,5,0.39,0.937,0.912,0.93,5,1,0.063,0.0879,0.0695,-0.0065,-0.0009,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
9月 30 2021 12:35:02,64,31,112,56,0.5,0.812,0.818,0.818,5,1,0.1881,0.1818,0.1818,0.0063,0.0023,快速排序在分割数组时比选择第一个数作为基准更好的做法是？
9月 30 2021 12:35:17,43,33,119,70,0.58,0.802,0.819,0.981,5,1,0.1982,0.1807,0.0191,0.1791,0.0389,对某数组进行希尔排序(Shell sort)_进行增量为h的排序，就是说对该数组 [.] 。
9月 30 2021 12:36:30,41,34,122,53,0.43,0.797,0.83,0.982,5,1,0.2028,0.1701,0.018,0.1848,0.0408,数组原地排序算法中所需要交换两个元素操作最少的算法是？
10月 01 2021 11:38:53,48,33,119,78,0.66,0.803,0.848,0.984,5,1,0.1968,0.1522,0.0163,0.1805,0.0385,归并排序最主要的缺点是？
Oct 02 2021 10:24:55,53,6,16,11,0.69,0.89,0.885,0.885,5,1,0.1105,0.1151,0.1151,-0.0046,-0.001,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Oct 08 2021 09:50:57,79,11,33,95,2.88,0.93,0.953,0.992,5,1,0.0702,0.0474,0.0082,0.062,0.0049,简述最大堆的定义。
Oct 08 2021 09:51:07,20,9,30,16,0.52,0.956,0.917,0.917,5,1,0.0442,0.0832,0.0832,-0.0391,-0.005,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
Oct 08 2021 09:51:23,11,46,165,90,0.55,0.962,0.952,0.968,5,1,0.0379,0.0478,0.0322,0.0057,0.0004,如果a和b是正整数且a > b，那么简述计算gcd(a_b)的欧几里得算法。
Oct 08 2021 10:03:05,9,20,75,37,0.5,0.955,0.871,0.871,5,1,0.0452,0.1288,0.1288,-0.0836,-0.0146,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Oct 08 2021 10:04:03,42,42,157,98,0.63,0.758,0.83,0.983,5,1,0.2418,0.1701,0.0172,0.2246,0.0582,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Oct 08 2021 10:04:10,26,51,191,153,0.8,0.715,0.822,0.982,5,1,0.2846,0.1784,0.0175,0.2671,0.0807,一个环状缓冲区(ring buffer）数据结构上被实现为一个 [.] 。
Oct 08 2021 10:04:45,47,41,154,124,0.8,0.765,0.872,0.986,5,1,0.2353,0.1279,0.0137,0.2216,0.0552,归并排序的时间复杂度是？ (big O)
Oct 09 2021 10:47:28,4,84,315,178,0.57,0.965,0.919,0.954,5,1,0.0354,0.0812,0.046,-0.0107,-0.0009,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
Oct 10 2021 18:29:16,46,43,161,102,0.64,0.755,0.871,0.986,5,1,0.2445,0.1292,0.0136,0.2309,0.0596,插入排序的时间复杂度是？（big O）
Oct 10 2021 18:30:16,6,47,169,117,0.69,0.973,0.956,0.956,5,1,0.0268,0.0445,0.0445,-0.0177,-0.0013,写出计算正整数lo和正整数hi (lo <= hi) 的中间值整数mid的表达式，并且不能有溢出风险。
10月 11 2021 11:05:30,36,46,172,162,0.94,0.742,0.864,0.986,5,1,0.2585,0.1356,0.0139,0.2446,0.0666,union-find algorithm(并查集算法）中quick union相比quick find在find方法中的区别是？
10月 12 2021 11:10:46,69,18,59,109,1.85,0.932,0.966,0.983,5,1,0.0678,0.0338,0.0169,0.051,0.0043,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Oct 14 2021 11:59:59,73,25,79,40,0.5,0.534,0.888,0.924,5,1,0.4659,0.1119,0.0763,0.3896,0.2112,证明：任何基于比较的排序算法至少会进行N lgN次比较。  假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 N! 则比较的次数大约是 [.]。
Oct 14 2021 12:00:44,44,25,79,52,0.66,0.534,0.889,0.938,5,1,0.4659,0.1106,0.0619,0.404,0.2132,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Oct 14 2021 12:04:42,75,25,94,114,1.22,0.85,0.923,0.99,5,1,0.1496,0.0766,0.0098,0.1398,0.0223,简述求第k小元素的Quick Select算法。
Oct 14 2021 12:04:49,49,46,172,113,0.66,0.743,0.864,0.986,5,1,0.2571,0.1356,0.0135,0.2435,0.0659,归并排序可以通过在排序比较小的数组的时候进行 [.] 来提升速度。
Oct 14 2021 12:04:53,53,12,38,20,0.53,0.951,0.898,0.898,5,1,0.0489,0.1022,0.1022,-0.0533,-0.0081,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Oct 14 2021 12:04:57,50,46,172,156,0.91,0.744,0.865,0.987,5,1,0.2564,0.1355,0.0134,0.243,0.0656,简述证明任何基于比较的排序在最坏情况下都需要lg N!次比较。
Oct 15 2021 10:06:56,10,41,147,155,1.05,0.978,0.964,0.964,5,1,0.022,0.0364,0.0364,-0.0144,-0.0008,brute force算法是什么？
Oct 15 2021 10:07:05,8,42,151,102,0.68,0.977,0.963,0.963,5,1,0.0226,0.0374,0.0374,-0.0148,-0.0009,将十进制数x转换为2进制字符串，对x不断进行除2操作，获得的余数为r1_r2_r3_._rk，则最终的转换结果为？
Oct 15 2021 10:30:58,61,14,44,95,2.16,0.914,0.957,0.993,5,1,0.086,0.0431,0.0074,0.0786,0.0073,用数组保存完全二叉堆，则根节点的下标是？
Oct 15 2021 10:31:02,99,2,6,23,3.86,0.987,0.994,0.995,5,1,0.0127,0.006,0.0051,0.0077,0.0001,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含2个值的节点有[.]个子节点
Oct 15 2021 10:33:42,72,26,82,53,0.64,0.521,0.884,0.943,5,1,0.4791,0.1158,0.0567,0.4224,0.2263,证明：任何基于比较的排序算法至少会进行N lgN次比较。 假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 [.]则比较的次数大约是 该比较树的高度。
Oct 15 2021 10:34:44,52,46,172,115,0.67,0.745,0.863,0.987,5,1,0.2546,0.1366,0.013,0.2416,0.0646,快速排序的时间复杂度是？（big O）
Oct 16 2021 17:05:35,119,1,3,27,8.96,0.994,0.996,0.995,5,1,0.0063,0.004,0.0049,0.0014,0.0000,VSAM通常作为大型索引顺序文件的标准组织，其动态索引结构采用的是 [.]。
Oct 16 2021 17:06:04,98,3,9,68,7.52,0.981,0.99,0.995,5,1,0.0189,0.01,0.0053,0.0136,0.0003,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含[.]个值的节点有3个子节点
10月 17 2021 11:46:52,87,16,53,127,2.4,0.904,0.951,0.992,5,1,0.0964,0.0492,0.0076,0.0889,0.0092,简述最大堆的swim操作。
10月 17 2021 11:47:03,65,17,56,82,1.46,0.898,0.949,0.992,5,1,0.1019,0.0513,0.0076,0.0943,0.0103,用数组保存完全二叉堆，如果父节点的下标是k_那么两个子节点的下标分别是？
10月 17 2021 11:47:25,33,53,199,196,0.98,0.716,0.847,0.987,5,1,0.2841,0.1531,0.0133,0.2708,0.0806,简述算法复杂度符号big Theta的定义（利用其它算法复杂度符号）：. （Image #6: d:\supermemo\systems\algorithm\temp\PastedImage11552.jpg）
Oct 18 2021 12:16:57,89,17,56,125,2.23,0.899,0.948,0.992,5,1,0.1014,0.0523,0.0076,0.0938,0.0102,简述heapsort中的sink-based heap construction: 利用sink(k)操作定义heapify操作： heapify(k)将以下标k为根节点的sub-heap变为ordered sub-heap。
Oct 19 2021 11:16:33,15,40,144,226,1.57,0.978,0.967,0.983,5,1,0.0222,0.0334,0.0167,0.0055,0.0002,在java的类定义public class FixedCapacityStack<Item>中. a = new Item[cap];. 需要被写成. a = (Item[]) new Object[cap];. 的原因是？
Oct 20 2021 09:58:22,76,31,116,137,1.18,0.823,0.906,0.99,5,1,0.1768,0.0938,0.0098,0.167,0.0312,二分插入排序的算法复杂度是O(N lgN)，但其存在的致命性的缺点是？
Oct 21 2021 10:35:41,70,32,120,115,0.96,0.818,0.904,0.99,5,1,0.1816,0.0964,0.0099,0.1717,0.0329,medians of medians算法需要每次将数组分为 [.] 份。
Oct 21 2021 10:36:31,77,32,120,190,1.59,0.819,0.904,0.99,5,1,0.1813,0.0965,0.0098,0.1715,0.0328,medians of medians算法在quick select算法中的用途是？
Oct 21 2021 10:38:36,58,52,195,185,0.95,0.723,0.848,0.987,5,1,0.277,0.1522,0.0126,0.2644,0.0766,进行双路的Bottom-up merge sort，则每次进行的合并操作的两个子数组的长度是？（从第一次循环开始列出.)
Oct 21 2021 10:38:48,35,56,210,175,0.84,0.706,0.837,0.987,5,1,0.2943,0.163,0.0131,0.2812,0.0864,union-find algorithm(并查集算法）最常见的用途是？
Oct 21 2021 10:42:46,74,33,14,1,0.07,0.815,0.901,0.99,2,0,0.8147,0.9013,0.9903,-0.1756,-0.317,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
Oct 21 2021 10:43:22,68,32,101,49,0.49,0.448,0.861,0.94,5,1,0.5519,0.139,0.0602,0.4917,0.301,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Oct 22 2021 11:30:20,81,21,72,156,2.16,0.878,0.936,0.992,5,1,0.1221,0.0645,0.008,0.1141,0.0148,最大堆的插入复杂度和删除最大元素的复杂度分别是？
Oct 22 2021 11:31:03,74,1,2,3,1.42,0.992,0.897,0.942,5,1,0.0075,0.1032,0.0579,-0.0503,-0.0033,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
10月 23 2021 11:04:46,84,22,76,167,2.2,0.873,0.933,0.992,5,1,0.1268,0.0673,0.0081,0.1187,0.016,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
10月 23 2021 11:04:58,82,22,76,129,1.7,0.873,0.933,0.992,5,1,0.1266,0.0674,0.0081,0.1185,0.016,简述如何向最大堆中添加一个元素。
10月 23 2021 11:05:45,56,54,202,178,0.88,0.718,0.842,0.988,5,1,0.2823,0.1577,0.0124,0.2699,0.0795,简述插入排序中将某元素往前插入到适当位置的方式。 （利用交换两元素的位置的操作）
10月 23 2021 11:30:59,37,32,120,172,1.43,0.979,0.974,0.986,5,1,0.0214,0.0264,0.0138,0.0076,0.0003,union-find algorithm(并查集算法）中weighted quick union相比quick union在union方法中的区别是？
10月 24 2021 13:34:19,126,1,3,24,8.09,0.994,0.997,0.995,5,1,0.0061,0.0028,0.0049,0.0012,0.0000,红黑树是一种变形的2-3 tree，它是如何编码3-node的？
10月 24 2021 13:34:40,20,16,58,29,0.51,0.966,0.898,0.919,5,1,0.0341,0.1022,0.0812,-0.0471,-0.0054,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
10月 25 2021 10:51:15,74,3,8,7,0.88,0.89,0.899,0.899,5,1,0.1105,0.1013,0.1013,0.0092,0.002,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
10月 25 2021 10:59:34,63,31,116,144,1.24,0.978,0.974,0.986,5,1,0.0215,0.0258,0.0136,0.008,0.0003,快速排序可以通过在排序比较小的数组的时候进行 [.] 来提升速度。
Oct 27 2021 09:28:24,83,26,97,171,1.76,0.853,0.921,0.992,5,1,0.1471,0.0789,0.0085,0.1387,0.0216,用数组保存完全三叉堆，如果父节点的下标是k，那么三个子节点的下标分别是？
10月 28 2021 11:42:02,14,52,187,228,1.22,0.969,0.96,0.982,5,1,0.0305,0.0405,0.0181,0.0125,0.0006,java中为了将基础值类型作为泛型参数时的便利性（自动将基础类型和其对应的引用类型转换），提供了什么样的功能？
10月 28 2021 11:42:36,3,76,285,246,0.86,0.972,0.945,0.977,5,1,0.0285,0.0547,0.0233,0.0052,0.0003,page rank算法中，如果用N表示node的数量，d代表用户从某页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
10月 30 2021 12:41:09,51,34,127,183,1.44,0.978,0.973,0.987,5,1,0.0219,0.0265,0.0129,0.0089,0.0003,归并排序（是/不是）原地排序算法。
Oct 31 2021 10:47:52,88,30,112,182,1.63,0.832,0.909,0.991,5,1,0.1675,0.0907,0.009,0.1585,0.028,简述最大堆的sink操作。
Oct 31 2021 10:47:59,27,37,139,177,1.27,0.979,0.97,0.986,5,1,0.0214,0.0301,0.0142,0.0072,0.0003,2-sum：给一个数组，找到其中所有和为0的序对，简述在线性时间内完成的思路。
Nov 01 2021 12:23:24,74,7,23,11,0.49,0.943,0.901,0.901,5,1,0.0569,0.0994,0.0994,-0.0425,-0.0066,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
Nov 01 2021 12:23:28,62,35,131,159,1.21,0.978,0.973,0.987,5,1,0.0217,0.0274,0.0133,0.0084,0.0003,为了防止快速排序最坏的情况发生，在排序前需要进行 [.] 。
Nov 02 2021 10:39:56,92,22,79,141,1.78,0.874,0.933,0.992,5,1,0.1256,0.0673,0.0079,0.1178,0.0157,简述如何获取二叉搜索树中最小的节点。
Nov 02 2021 10:40:34,12,56,201,301,1.5,0.972,0.964,0.986,5,1,0.0276,0.0362,0.0137,0.0138,0.0006,洗牌算法：将长度为N的数组arr打乱：. for(int i=0;i<N-1;i++){.    将数组arr中第i个元素和[.]交换。. }
Nov 02 2021 10:40:44,18,63,227,186,0.82,0.953,0.948,0.978,5,1,0.0474,0.0523,0.0224,0.0249,0.0017,用数组实现循环队列的经典做法：维护两个指针： 1.front指针指向队列中第一个元素 2.tail指针指向 [.] 。
Nov 03 2021 10:38:11,102,21,76,109,1.43,0.88,0.936,0.992,5,1,0.1201,0.0644,0.0077,0.1124,0.0144,简述如何将某个值插入到2-3 search trees（2-3搜索树）中的某个2-node上。
Nov 03 2021 10:40:25,55,33,124,151,1.21,0.818,0.901,0.991,5,1,0.1819,0.0994,0.0092,0.1726,0.033,简述如何删除最大堆中的最大元素（根节点）。
Nov 03 2021 10:40:49,53,20,69,36,0.52,0.966,0.913,0.913,5,1,0.0338,0.0868,0.0868,-0.053,-0.0064,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Nov 03 2021 10:41:02,19,61,219,263,1.2,0.959,0.953,0.981,5,1,0.0409,0.0475,0.0192,0.0217,0.0013,用数组实现循环队列的经典做法：如果数组的长度为10，那么实际队列的最大长度为 [.] 。
11月 04 2021 12:03:32,104,22,79,127,1.61,0.875,0.932,0.992,5,1,0.1251,0.0675,0.0078,0.1173,0.0156,简述如何将某个值插入到2-3 search trees（2-3搜索树）中的某个3-node上。
11月 04 2021 12:07:07,80,35,131,113,0.87,0.809,0.896,0.991,5,1,0.1912,0.1044,0.0093,0.1819,0.0365,用数组保存完全二叉堆，如果子节点的下标是k，那么父节点的下标是？
Nov 05 2021 10:15:21,101,23,86,124,1.45,0.87,0.93,0.992,5,1,0.13,0.0704,0.0078,0.1222,0.0168,2-3 search trees中（2-node/3-node) 是指包含2个值，有3个子节点的节点。
11月 06 2021 11:19:48,13,64,230,255,1.11,0.959,0.952,0.981,5,1,0.0414,0.0483,0.0194,0.022,0.0013,java中int类型和Integer类型的区别是？
11月 07 2021 10:04:42,99,23,76,80,1.05,0.764,0.929,0.971,5,1,0.2361,0.0706,0.0292,0.2069,0.0549,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含2个值的节点有[.]个子节点
11月 07 2021 10:04:54,7,76,273,267,0.98,0.956,0.944,0.978,5,1,0.0443,0.0562,0.0221,0.0222,0.0015,算法中维护一段数组上的闭区间[lo_hi]，并通过while循环不断迭代修改该区间的范围: while( [.] ) { . }
11月 07 2021 10:05:06,29,50,187,163,0.87,0.962,0.959,0.983,5,1,0.0378,0.0409,0.017,0.0208,0.0011,简述算法复杂度符号~的定义： f(N) ~ g(N)，即 [.] 。
11月 07 2021 10:09:04,34,40,150,234,1.56,0.979,0.972,0.99,5,1,0.0211,0.0277,0.0098,0.0112,0.0003,扔鸡蛋问题：现在有有限个鸡蛋，求鸡蛋不会碎的最大楼层，简述解题思路。
11月 07 2021 10:09:21,16,70,252,147,0.58,0.943,0.941,0.979,5,1,0.0571,0.0591,0.0215,0.0356,0.0028,java中某个类如果想要用foreach遍历它，那么这个类需要满足什么条件？
11月 10 2021 21:10:37,86,40,150,196,1.31,0.785,0.879,0.99,5,1,0.2148,0.1205,0.0099,0.2049,0.0461,为了能够随时改变优先队列中的元素的优先度，通常采用什么技术？
11月 10 2021 21:11:17,31,43,161,279,1.73,0.978,0.971,0.99,5,1,0.022,0.0294,0.0099,0.0121,0.0004,简述算法复杂度符号small o的定义（利用极限）： f(N) = o(g(N))
11月 10 2021 21:12:08,22,70,252,242,0.96,0.95,0.944,0.981,5,1,0.0504,0.0557,0.0192,0.0312,0.0022,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。  则表示队列中元素数量的表达式为 [.] 。
Nov 11 2021 19:39:01,123,27,101,141,1.4,0.85,0.918,0.992,5,1,0.1504,0.0822,0.0082,0.1422,0.0226,简述连通图的定义。
Nov 11 2021 19:39:33,94,31,116,122,1.05,0.829,0.905,0.991,5,1,0.1705,0.0947,0.0087,0.1618,0.029,简述如何删除二叉搜索树（Binary Search Tree)中某个节点。
Nov 11 2021 19:39:47,120,27,101,112,1.11,0.85,0.916,0.992,5,1,0.1501,0.0837,0.0082,0.1418,0.0225,m阶B树中所有节点所有拥有的子节点个数不超过 [.] 个。
Nov 13 2021 19:14:06,106,30,112,128,1.14,0.835,0.908,0.991,5,1,0.1651,0.0917,0.0085,0.1566,0.0272,简述算法中广义表(generalized table)的定义。
Nov 13 2021 19:14:13,74,12,43,24,0.55,0.967,0.913,0.932,5,1,0.0329,0.0865,0.0684,-0.0355,-0.0036,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
Nov 13 2021 19:15:41,21,56,210,443,2.11,0.977,0.973,0.991,5,1,0.0231,0.0267,0.0089,0.0142,0.0005,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。 . 则判断队列是否为满的表达式为 [.] 。
Nov 13 2021 19:15:55,90,33,124,165,1.33,0.82,0.899,0.991,5,1,0.1798,0.1008,0.0088,0.171,0.0323,简述一棵二叉搜索树（Binary Search Tree）的定义。
Nov 13 2021 19:16:41,103,31,116,162,1.4,0.83,0.905,0.991,5,1,0.1697,0.0948,0.0086,0.1611,0.0287,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
11月 14 2021 20:46:01,38,51,191,270,1.41,0.97,0.96,0.985,5,1,0.0304,0.0396,0.0147,0.0157,0.0007,union-find algorithm(并查集算法）中weighted quick union中使用路径压缩，就是说？
11月 14 2021 21:01:13,9,37,139,198,1.43,0.97,0.885,0.991,5,1,0.0305,0.1154,0.0093,0.0211,0.0008,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Nov 15 2021 11:49:31,122,31,116,165,1.42,0.83,0.907,0.992,5,1,0.1695,0.0929,0.0084,0.1611,0.0287,简述无向图中某顶点v的度的定义。
Nov 15 2021 11:55:48,113,32,120,133,1.1,0.826,0.904,0.992,5,1,0.1743,0.0959,0.0085,0.1658,0.0303,基数排序的MSD(Most Significant Digit)法是指？
11月 18 2021 12:36:56,126,25,82,84,1.02,0.534,0.902,0.964,5,1,0.4659,0.0983,0.0361,0.4298,0.2157,红黑树是一种变形的2-3 tree，它是如何编码3-node的？
11月 18 2021 12:37:34,107,35,14,1,0.1,0.811,0.895,0.991,2,0,0.8112,0.8947,0.9912,-0.18,-0.3244,简述算法中有向无环图的拓扑序列的定义。
Nov 19 2021 10:41:45,112,36,135,206,1.52,0.807,0.893,0.991,5,1,0.1934,0.1074,0.0089,0.1845,0.0373,简述如何从一些带权的节点中构造一颗霍夫曼树(Huffman Tree).
Nov 19 2021 10:41:55,107,1,2,7,3.67,0.993,0.908,0.954,5,1,0.0073,0.0924,0.0458,-0.0385,-0.002,简述算法中有向无环图的拓扑序列的定义。
Nov 19 2021 10:42:04,111,36,135,150,1.11,0.807,0.892,0.991,5,1,0.1927,0.1076,0.0088,0.1839,0.0371,简述霍夫曼树（Huffman Tree）的定义。
Nov 19 2021 10:42:25,25,51,191,375,1.96,0.979,0.977,0.992,5,1,0.0206,0.0233,0.008,0.0126,0.0004,单向链表如何在O(1)内实现末尾插入操作。
Nov 20 2021 11:04:41,124,36,135,207,1.53,0.807,0.893,0.991,5,1,0.1925,0.1072,0.0088,0.1838,0.037,通常将树定义为 [.] 图。
Nov 22 2021 16:27:22,41,53,199,309,1.55,0.973,0.967,0.991,5,1,0.027,0.0334,0.0094,0.0176,0.0006,数组原地排序算法中所需要交换两个元素操作最少的算法是？
Nov 22 2021 16:27:36,20,29,109,46,0.42,0.969,0.892,0.892,5,1,0.0313,0.1075,0.1075,-0.0762,-0.0106,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
Nov 23 2021 11:25:16,73,40,138,184,1.33,0.967,0.958,0.985,5,1,0.0325,0.0424,0.0155,0.017,0.0008,证明：任何基于比较的排序算法至少会进行N lgN次比较。  假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 N! 则比较的次数大约是 [.]。
11月 24 2021 10:13:06,115,32,120,151,1.26,0.827,0.904,0.992,5,1,0.1729,0.0963,0.0083,0.1646,0.0298,简述红黑树的rotateLeft操作。
11月 24 2021 10:15:20,116,41,154,179,1.17,0.784,0.879,0.991,5,1,0.2158,0.1213,0.0092,0.2065,0.0465,简述二叉树的前序(Pre-order)访问的定义。
Nov 25 2021 15:57:14,91,45,169,237,1.4,0.766,0.866,0.99,5,1,0.2339,0.1341,0.0096,0.2243,0.0546,二叉搜索树（Binary Search Tree）在最坏情况下会退化为 [.] 。
Nov 25 2021 15:57:59,64,56,210,303,1.44,0.969,0.961,0.99,5,1,0.0312,0.0388,0.01,0.0212,0.0009,快速排序在分割数组时比选择第一个数作为基准更好的做法是？
Nov 25 2021 15:58:37,59,65,243,205,0.84,0.949,0.948,0.983,5,1,0.0506,0.0521,0.0172,0.0333,0.0023,归并排序的合并操作在什么情况下是可以被省略的。
Nov 26 2021 11:25:47,107,7,19,11,0.6,0.761,0.748,0.765,5,1,0.239,0.2521,0.2354,0.0037,0.0017,简述算法中有向无环图的拓扑序列的定义。
Nov 26 2021 11:25:55,100,44,165,212,1.29,0.771,0.869,0.991,5,1,0.2292,0.1308,0.0095,0.2197,0.0524,算法中一颗树（tree）是平衡的（balanced）是指什么？
Nov 29 2021 11:35:29,114,46,172,209,1.22,0.762,0.865,0.99,5,1,0.238,0.1354,0.0096,0.2284,0.0566,基数排序的LSD(Most Significant Digit)法是指？
Dec 01 2021 13:39:36,23,68,255,301,1.18,0.975,0.976,0.976,5,1,0.0246,0.0244,0.0244,0.0001,0,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。  则tail指针的后一个位置的表达式为 [.] 。
Dec 08 2021 16:03:30,72,54,186,226,1.21,0.958,0.943,0.983,5,1,0.042,0.0568,0.0175,0.0245,0.0015,证明：任何基于比较的排序算法至少会进行N lgN次比较。 假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 [.]则比较的次数大约是 该比较树的高度。
Dec 08 2021 16:03:48,117,55,206,201,0.98,0.723,0.84,0.99,5,1,0.2773,0.1604,0.0104,0.2669,0.0768,简述二叉树的后序（Post-order）访问的定义。
Dec 08 2021 16:06:18,93,58,217,170,0.79,0.71,0.831,0.989,5,1,0.2897,0.1692,0.0107,0.2791,0.0838,简述如何获取二叉搜索树中最大的节点。
Dec 08 2021 16:06:51,74,25,94,38,0.41,0.964,0.907,0.927,5,1,0.0359,0.0929,0.0734,-0.0375,-0.0041,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
Dec 08 2021 16:07:17,57,80,300,186,0.62,0.932,0.933,0.981,5,1,0.0678,0.0666,0.0189,0.0489,0.0042,归并排序中对 [lo.hi] 的部分进行分割为两部分后分别排序，如果mid = lo + (hi - lo)/2_ 那么分割为哪两部分（尽量使得两部分一样长）？
Dec 08 2021 16:08:35,107,12,38,33,0.87,0.958,0.888,0.922,5,1,0.0421,0.1116,0.078,-0.0359,-0.0043,简述算法中有向无环图的拓扑序列的定义。
Dec 08 2021 16:09:31,44,55,15,4,0.26,0.956,0.942,0.984,2,0,0.9556,0.9424,0.9838,-0.0283,-0.0548,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Dec 09 2021 11:23:54,68,49,169,212,1.25,0.969,0.959,0.987,5,1,0.0311,0.0409,0.0126,0.0185,0.0008,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Dec 09 2021 11:24:35,43,70,262,360,1.37,0.963,0.956,0.989,5,1,0.0366,0.0445,0.0106,0.0259,0.0012,对某数组进行希尔排序(Shell sort)_进行增量为h的排序，就是说对该数组 [.] 。
Dec 09 2021 11:24:51,53,36,135,37,0.27,0.967,0.926,0.926,5,1,0.0327,0.0737,0.0737,-0.041,-0.0044,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Dec 10 2021 17:13:02,132,33,15,1,0.07,0.823,0.9,0.992,2,0,0.8233,0.8998,0.9917,-0.1685,-0.3058,红黑树每次进行完插入工作后需要 [.] 。
Dec 10 2021 17:16:38,130,33,15,1,0.07,0.823,0.9,0.992,2,0,0.8234,0.8997,0.9917,-0.1683,-0.3055,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
Dec 11 2021 11:17:08,132,1,2,1,0.74,0.993,0.924,0.966,5,1,0.0072,0.0763,0.0343,-0.0271,-0.0011,红黑树每次进行完插入工作后需要 [.] 。
Dec 11 2021 11:17:20,130,1,2,1,0.71,0.993,0.924,0.969,5,1,0.0072,0.076,0.0312,-0.024,-0.0009,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
Dec 11 2021 11:24:07,128,34,15,1,0.07,0.82,0.897,0.992,2,0,0.8195,0.8975,0.9917,-0.1721,-0.3118,红黑树（左倾的）中如何将值插入一个2-node？
Dec 12 2021 10:31:42,128,1,2,3,1.32,0.993,0.903,0.964,5,1,0.0072,0.0965,0.0355,-0.0283,-0.0012,红黑树（左倾的）中如何将值插入一个2-node？
Dec 12 2021 10:32:05,44,4,9,9,0.97,0.972,0.672,0.897,5,1,0.0283,0.3275,0.1032,-0.0749,-0.0098,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Dec 13 2021 12:25:56,132,2,5,4,0.76,0.916,0.898,0.898,5,1,0.0841,0.1021,0.1021,-0.0181,-0.0034,红黑树每次进行完插入工作后需要 [.] 。
Dec 13 2021 12:26:41,131,36,135,145,1.08,0.811,0.892,0.991,5,1,0.1891,0.1083,0.0085,0.1806,0.0357,红黑树（左倾的）中如何将值b插入一个3-node，并且b的值介于a和c？ 如图： Image #16: d:\supermemo\systems\algorithm\temp\PastedImage8255.jpg
Dec 13 2021 12:26:46,130,2,5,5,0.95,0.916,0.898,0.919,5,1,0.0841,0.1025,0.0815,0.0026,0.0004,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
12月 15 2021 11:27:45,128,3,8,7,0.93,0.877,0.885,0.885,5,1,0.1234,0.1151,0.1151,0.0083,0.002,红黑树（左倾的）中如何将值插入一个2-node？
Dec 17 2021 10:09:17,132,4,13,10,0.77,0.951,0.924,0.94,5,1,0.0489,0.0758,0.0601,-0.0111,-0.0012,红黑树每次进行完插入工作后需要 [.] 。
12月 18 2021 12:46:24,130,5,16,9,0.59,0.939,0.904,0.937,5,1,0.0608,0.0961,0.063,-0.0022,-0.0003,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
12月 18 2021 13:07:58,32,88,15,2,0.16,0.944,0.938,0.987,2,0,0.9444,0.938,0.9872,-0.0428,-0.0827,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
12月 18 2021 13:08:06,48,78,292,322,1.1,0.959,0.95,0.989,5,1,0.0407,0.0497,0.0111,0.0295,0.0015,归并排序最主要的缺点是？
12月 18 2021 13:08:45,30,89,333,289,0.87,0.942,0.936,0.983,5,1,0.0583,0.0644,0.0169,0.0415,0.0031,简述算法复杂度符号big O的定义 (用常数c，N_0定义）：f(N) = O(g(N))
Dec 20 2021 13:40:32,97,43,15,1,0.07,0.779,0.872,0.991,2,0,0.7787,0.8723,0.9909,-0.2122,-0.3754,简述2-3 tree进行删除最小值的操作的思路。
Dec 20 2021 13:40:43,32,2,5,7,1.46,0.986,0.813,0.944,5,1,0.0142,0.1873,0.056,-0.0418,-0.0029,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
12月 21 2021 12:30:41,97,1,2,3,1.27,0.993,0.905,0.972,5,1,0.0071,0.0954,0.0284,-0.0213,-0.0008,简述2-3 tree进行删除最小值的操作的思路。
12月 21 2021 12:31:53,44,9,27,14,0.51,0.931,0.895,0.895,5,1,0.0693,0.1049,0.1049,-0.0356,-0.0062,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Dec 22 2021 10:55:08,128,7,22,10,0.47,0.943,0.902,0.923,5,1,0.0569,0.0979,0.0773,-0.0204,-0.0027,红黑树（左倾的）中如何将值插入一个2-node？
Dec 23 2021 10:15:26,98,68,224,111,0.5,0.588,0.844,0.939,5,1,0.4118,0.1562,0.0607,0.3511,0.1659,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含[.]个值的节点有3个子节点
Dec 24 2021 11:01:22,97,3,8,6,0.76,0.89,0.886,0.91,5,1,0.1105,0.1138,0.0896,0.0208,0.0042,简述2-3 tree进行删除最小值的操作的思路。
Dec 27 2021 10:41:08,132,10,34,20,0.57,0.95,0.891,0.925,5,1,0.0503,0.1092,0.0754,-0.0251,-0.0032,红黑树每次进行完插入工作后需要 [.] 。
Dec 27 2021 10:41:38,129,50,187,156,0.83,0.749,0.803,0.988,5,1,0.2513,0.1973,0.0115,0.2398,0.063,红黑树（左倾的）中如何将值c插入一个3-node，并且c比a和b都要大？. 如图：. MjAyMS0xMS0wNy0xNF8zNl81Mg==
Dec 27 2021 10:42:07,130,9,31,20,0.64,0.963,0.924,0.957,5,1,0.0365,0.0758,0.0431,-0.0066,-0.0005,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
Dec 27 2021 10:42:20,32,7,21,7,0.34,0.903,0.885,0.885,5,1,0.0974,0.1153,0.1153,-0.018,-0.0038,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
12月 28 2021 10:35:14,2,129,497,240,0.48,0.968,0.934,0.934,5,1,0.0323,0.0659,0.0659,-0.0336,-0.0033,假设背包问题中的物品有A_B_C，容量是4，那么所需要建立的动态规划表（dynamic programming table）的两列索引是？
Dec 30 2021 13:44:50,97,6,20,13,0.65,0.951,0.914,0.914,5,1,0.0489,0.0858,0.0858,-0.0368,-0.005,简述2-3 tree进行删除最小值的操作的思路。
Jan 01 2022 11:27:22,128,10,34,27,0.79,0.971,0.927,0.951,5,1,0.0291,0.0734,0.0485,-0.0194,-0.0015,红黑树（左倾的）中如何将值插入一个2-node？
Jan 04 2022 14:55:34,44,14,46,34,0.74,0.966,0.919,0.919,5,1,0.0336,0.081,0.081,-0.0475,-0.0054,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Jan 06 2022 10:32:41,32,10,34,20,0.58,0.969,0.926,0.963,5,1,0.0309,0.0739,0.0372,-0.0063,-0.0004,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
Jan 06 2022 10:38:50,11,90,337,313,0.93,0.966,0.969,0.975,5,1,0.0338,0.0312,0.0254,0.0084,0.0005,如果a和b是正整数且a > b，那么简述计算gcd(a_b)的欧几里得算法。
Jan 07 2022 12:59:03,65,82,295,236,0.8,0.91,0.925,0.981,5,1,0.0898,0.0748,0.019,0.0709,0.0077,用数组保存完全二叉堆，如果父节点的下标是k_那么两个子节点的下标分别是？
Jan 07 2022 12:59:35,20,46,172,60,0.35,0.974,0.902,0.902,5,1,0.0262,0.0978,0.0978,-0.0717,-0.0089,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
Jan 10 2022 10:57:50,107,33,114,47,0.41,0.945,0.839,0.839,5,1,0.0552,0.1609,0.1609,-0.1057,-0.0228,简述算法中有向无环图的拓扑序列的定义。
Jan 11 2022 10:15:26,79,95,324,145,0.45,0.825,0.888,0.975,5,1,0.1753,0.1118,0.0252,0.1501,0.0301,简述最大堆的定义。
Jan 12 2022 10:27:49,97,13,47,21,0.44,0.959,0.894,0.941,5,1,0.0414,0.106,0.0594,-0.018,-0.0018,简述2-3 tree进行删除最小值的操作的思路。
Jan 12 2022 10:27:54,45,114,425,255,0.6,0.916,0.914,0.98,5,1,0.0839,0.0859,0.0195,0.0644,0.0067,选择排序的时间复杂度是？ (big O)
Jan 18 2022 13:20:52,132,22,82,40,0.49,0.96,0.886,0.901,5,1,0.0398,0.1136,0.0986,-0.0588,-0.0081,红黑树每次进行完插入工作后需要 [.] 。
Jan 18 2022 13:21:01,130,22,82,65,0.79,0.956,0.918,0.946,5,1,0.0442,0.0822,0.0541,-0.0099,-0.001,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
Jan 18 2022 13:27:53,74,41,154,184,1.2,0.973,0.955,0.988,5,1,0.0271,0.0454,0.0123,0.0148,0.0006,香农熵（Shannon Entropy）的定义：一串信息中有n个不同的值，第i个值出现的概率为p_i_则该串信息的香农熵 H = [.] 。
Jan 18 2022 13:28:43,42,102,15,1,0.07,0.96,0.956,0.963,2,0,0.9602,0.9558,0.9634,-0.0032,-0.0061,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Jan 18 2022 13:29:15,61,95,327,255,0.78,0.869,0.905,0.98,5,1,0.1313,0.0955,0.0204,0.1109,0.0168,用数组保存完全二叉堆，则根节点的下标是？
Jan 19 2022 11:45:01,42,1,3,1,0.44,0.993,0.907,0.974,5,1,0.0071,0.0931,0.0263,-0.0192,-0.0006,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Jan 20 2022 12:28:53,46,102,397,264,0.67,0.961,0.958,0.965,5,1,0.0389,0.0422,0.0346,0.0043,0.0003,插入排序的时间复杂度是？（big O）
Jan 30 2022 15:47:45,128,29,109,93,0.85,0.948,0.863,0.955,5,1,0.0522,0.1373,0.0453,0.0069,0.0007,红黑树（左倾的）中如何将值插入一个2-node？
Jan 30 2022 15:47:55,69,110,391,193,0.49,0.885,0.885,0.977,5,1,0.1145,0.1153,0.023,0.0916,0.0126,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Jan 30 2022 15:48:46,99,84,302,127,0.42,0.931,0.877,0.956,5,1,0.0688,0.1232,0.0444,0.0244,0.0028,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含2个值的节点有[.]个子节点
Jan 30 2022 15:49:44,42,11,35,15,0.44,0.743,0.623,0.657,5,1,0.2571,0.3773,0.3425,-0.0854,-0.0512,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Jan 30 2022 15:49:49,32,24,86,33,0.38,0.957,0.92,0.954,5,1,0.0434,0.0804,0.0456,-0.0022,-0.0002,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
Jan 30 2022 16:03:05,8,107,401,358,0.89,0.956,0.967,0.974,5,1,0.0438,0.0326,0.0264,0.0173,0.0012,将十进制数x转换为2进制字符串，对x不断进行除2操作，获得的余数为r1_r2_r3_._rk，则最终的转换结果为？
Jan 30 2022 16:03:10,53,52,195,199,1.02,0.976,0.958,0.989,5,1,0.0239,0.0415,0.0109,0.0129,0.0004,快速排序在每一轮排序时都要将无序的数组分为 [.] 。
Feb 02 2022 19:23:17,97,21,79,91,1.16,0.972,0.92,0.974,5,1,0.028,0.0802,0.0261,0.0019,0.0001,简述2-3 tree进行删除最小值的操作的思路。
Feb 06 2022 16:55:17,75,115,448,422,0.94,0.926,0.917,0.983,5,1,0.0741,0.0826,0.0171,0.057,0.0052,简述求第k小元素的Quick Select算法。
Feb 06 2022 16:55:22,6,119,442,311,0.7,0.956,0.965,0.965,5,1,0.0441,0.0348,0.0348,0.0092,0.0007,写出计算正整数lo和正整数hi (lo <= hi) 的中间值整数mid的表达式，并且不能有溢出风险。
Feb 06 2022 16:56:32,49,115,448,316,0.71,0.959,0.958,0.966,5,1,0.041,0.0416,0.034,0.007,0.0005,归并排序可以通过在排序比较小的数组的时候进行 [.] 来提升速度。
Feb 07 2022 11:14:27,44,34,122,72,0.59,0.954,0.867,0.935,5,1,0.0463,0.1329,0.0647,-0.0184,-0.002,三路快速排序划分 (3-way quick partition By Dijkstra_s Solution):  现在将数组 [lo.hi] 划分为三部分：小于v的部分，等于v的部分，大于v的部分   划分过程中用到辅助变量lt，gt，i ： 1.已经确认小于v的部分：[lo.lt-1] 2.已经确认大于v的部分：[gt+1.hi] 3 .
Feb 07 2022 11:14:31,52,115,448,304,0.68,0.959,0.959,0.966,5,1,0.041,0.0412,0.0336,0.0074,0.0005,快速排序的时间复杂度是？（big O）
Feb 10 2022 12:09:04,126,84,302,204,0.67,0.937,0.899,0.98,5,1,0.0635,0.1008,0.0199,0.0435,0.0036,红黑树是一种变形的2-3 tree，它是如何编码3-node的？
Feb 10 2022 12:13:06,47,125,483,526,1.09,0.95,0.936,0.989,5,1,0.0503,0.0642,0.0114,0.039,0.0024,归并排序的时间复杂度是？ (big O)
Feb 13 2022 16:44:01,70,115,448,463,1.03,0.942,0.925,0.988,5,1,0.0583,0.0745,0.0123,0.0461,0.0033,medians of medians算法需要每次将数组分为 [.] 份。
Feb 14 2022 09:42:41,42,15,52,32,0.61,0.972,0.91,0.941,5,1,0.0278,0.09,0.0591,-0.0313,-0.0027,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Feb 20 2022 16:11:31,102,109,408,403,0.99,0.913,0.914,0.983,5,1,0.0871,0.0864,0.0171,0.07,0.0073,简述如何将某个值插入到2-3 search trees（2-3搜索树）中的某个2-node上。
Feb 20 2022 16:12:17,89,125,438,263,0.6,0.86,0.889,0.98,5,1,0.1396,0.1106,0.0201,0.1195,0.0191,简述heapsort中的sink-based heap construction: 利用sink(k)操作定义heapify操作： heapify(k)将以下标k为根节点的sub-heap变为ordered sub-heap。
Feb 21 2022 11:19:51,87,127,444,361,0.81,0.85,0.884,0.98,5,1,0.1503,0.1161,0.0203,0.13,0.0222,简述最大堆的swim操作。
Feb 25 2022 13:07:52,80,113,440,542,1.23,0.947,0.932,0.989,5,1,0.0526,0.0675,0.0113,0.0412,0.0026,用数组保存完全二叉堆，如果子节点的下标是k，那么父节点的下标是？
Feb 26 2022 12:42:49,107,47,176,81,0.46,0.974,0.89,0.89,5,1,0.026,0.1103,0.1103,-0.0844,-0.0115,简述算法中有向无环图的拓扑序列的定义。
Feb 28 2022 11:34:27,132,41,154,165,1.07,0.969,0.946,0.98,5,1,0.0307,0.0542,0.02,0.0107,0.0005,红黑树每次进行完插入工作后需要 [.] 。
Mar 01 2022 17:34:20,82,129,472,388,0.82,0.893,0.901,0.983,5,1,0.1066,0.0989,0.0174,0.0892,0.0111,简述如何向最大堆中添加一个元素。
Mar 03 2022 11:42:22,120,112,420,399,0.95,0.933,0.924,0.988,5,1,0.067,0.0764,0.0118,0.0552,0.0044,m阶B树中所有节点所有拥有的子节点个数不超过 [.] 个。
Mar 04 2022 12:54:54,32,33,124,107,0.86,0.976,0.915,0.962,5,1,0.0239,0.0847,0.0378,-0.0139,-0.0009,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
Mar 06 2022 12:10:10,76,137,525,522,0.99,0.927,0.909,0.987,5,1,0.0732,0.0905,0.013,0.0603,0.0052,二分插入排序的算法复杂度是O(N lgN)，但其存在的致命性的缺点是？
Mar 11 2022 21:32:15,104,127,469,368,0.79,0.901,0.903,0.983,5,1,0.0987,0.0974,0.0172,0.0815,0.0094,简述如何将某个值插入到2-3 search trees（2-3搜索树）中的某个3-node上。
Mar 11 2022 21:33:51,26,154,583,345,0.59,0.948,0.95,0.957,5,1,0.0518,0.0503,0.0429,0.0089,0.0008,一个环状缓冲区(ring buffer）数据结构上被实现为一个 [.] 。
Mar 11 2022 21:33:58,101,126,468,402,0.86,0.911,0.905,0.983,5,1,0.0888,0.0946,0.0168,0.0719,0.0076,2-3 search trees中（2-node/3-node) 是指包含2个值，有3个子节点的节点。
Mar 11 2022 21:36:09,20,63,245,111,0.45,0.977,0.906,0.926,5,1,0.0226,0.0937,0.074,-0.0513,-0.005,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
Mar 15 2022 10:42:03,94,124,461,608,1.32,0.935,0.919,0.988,5,1,0.0654,0.0812,0.0116,0.0539,0.0041,简述如何删除二叉搜索树（Binary Search Tree)中某个节点。
Mar 18 2022 20:59:49,63,144,549,355,0.65,0.922,0.948,0.965,5,1,0.0775,0.0517,0.0347,0.0428,0.0048,快速排序可以通过在排序比较小的数组的时候进行 [.] 来提升速度。
Mar 18 2022 21:02:18,42,32,12,1,0.08,0.961,0.874,0.991,2,0,0.9613,0.874,0.9909,-0.0296,-0.0578,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Mar 19 2022 15:36:46,10,155,560,207,0.37,0.932,0.882,0.882,5,1,0.0685,0.1176,0.1176,-0.0491,-0.0091,brute force算法是什么？
Mar 19 2022 16:00:50,42,1,2,5,2.35,0.992,0.92,0.978,5,1,0.0085,0.0799,0.0219,-0.0135,-0.0004,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Mar 19 2022 16:00:54,50,156,591,219,0.37,0.942,0.925,0.925,5,1,0.0577,0.0748,0.0748,-0.0171,-0.0023,简述证明任何基于比较的排序在最坏情况下都需要lg N!次比较。
Mar 21 2022 18:30:46,106,128,476,135,0.28,0.93,0.871,0.897,5,1,0.0697,0.1291,0.1033,-0.0336,-0.0058,简述算法中广义表(generalized table)的定义。
Mar 22 2022 12:28:30,36,162,611,213,0.35,0.94,0.922,0.922,5,1,0.0604,0.0775,0.0775,-0.0172,-0.0024,union-find algorithm(并查集算法）中quick union相比quick find在find方法中的区别是？
Mar 23 2022 11:51:39,92,141,517,328,0.63,0.89,0.858,0.977,5,1,0.1104,0.1418,0.0231,0.0874,0.0117,简述如何获取二叉搜索树中最小的节点。
Mar 24 2022 15:39:39,130,65,176,108,0.62,0.952,0.918,0.973,3,1,0.0482,0.0822,0.0266,0.0216,0.0016,红黑树（左倾的）中如何将值a插入一个3-node，并且值a比b和c都要小。. 如图：. MjAyMS0xMS0wNy0xNF8zOF8yNA==
Mar 24 2022 15:39:52,42,5,15,7,0.48,0.864,0.777,0.805,5,1,0.1361,0.2226,0.1948,-0.0587,-0.0194,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Mar 27 2022 13:34:45,81,156,538,315,0.59,0.862,0.843,0.976,5,1,0.1377,0.1572,0.0244,0.1133,0.0184,最大堆的插入复杂度和删除最大元素的复杂度分别是？
Mar 28 2022 11:04:01,113,133,513,241,0.47,0.932,0.867,0.926,5,1,0.0683,0.1328,0.0738,-0.0055,-0.0008,基数排序的MSD(Most Significant Digit)法是指？
Apr 01 2022 11:10:04,123,141,520,148,0.28,0.914,0.864,0.925,5,1,0.0859,0.1358,0.0754,0.0105,0.0017,简述连通图的定义。
Apr 01 2022 11:10:43,42,8,28,17,0.62,0.965,0.91,0.96,5,1,0.0345,0.0896,0.0399,-0.0053,-0.0004,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Apr 03 2022 10:19:37,55,151,574,226,0.39,0.923,0.851,0.917,5,1,0.0766,0.1492,0.0826,-0.006,-0.001,简述如何删除最大堆中的最大元素（根节点）。
Apr 03 2022 10:19:45,16,147,536,353,0.66,0.962,0.95,0.967,5,1,0.0379,0.0496,0.0334,0.0045,0.0003,java中某个类如果想要用foreach遍历它，那么这个类需要满足什么条件？
Apr 05 2022 11:27:42,4,178,664,324,0.49,0.962,0.935,0.957,5,1,0.0375,0.0652,0.0433,-0.0058,-0.0005,假设某页面的page rank值为r，该页面上的链接数为n，那么该页面对另一个页面（假设该页面有一个到另一页面的链接）的贡献值是？
Apr 08 2022 10:37:01,84,167,15,1,0.07,0.857,0.834,0.976,2,0,0.8571,0.8343,0.9759,-0.1188,-0.2178,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
Apr 09 2022 21:22:05,84,1,2,2,0.88,0.993,0.859,0.966,5,1,0.0069,0.1415,0.034,-0.0271,-0.0011,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
Apr 09 2022 21:22:13,62,159,602,320,0.53,0.923,0.935,0.963,5,1,0.0768,0.0651,0.0373,0.0395,0.0045,为了防止快速排序最坏的情况发生，在排序前需要进行 [.] 。
Apr 12 2022 11:35:50,84,3,9,4,0.43,0.916,0.934,0.962,5,1,0.0841,0.0657,0.0377,0.0464,0.0056,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
Apr 13 2022 11:32:03,98,111,396,295,0.75,0.968,0.89,0.983,5,1,0.0318,0.1099,0.0175,0.0144,0.0007,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含[.]个值的节点有3个子节点
Apr 13 2022 11:33:28,37,172,645,302,0.47,0.908,0.927,0.958,5,1,0.0918,0.0731,0.0417,0.0501,0.0067,union-find algorithm(并查集算法）中weighted quick union相比quick union在union方法中的区别是？
Apr 14 2022 09:14:20,35,175,654,209,0.32,0.945,0.923,0.923,5,1,0.0546,0.0768,0.0768,-0.0221,-0.0029,union-find algorithm(并查集算法）最常见的用途是？
Apr 16 2022 11:09:57,83,171,641,223,0.35,0.889,0.836,0.93,5,1,0.111,0.1639,0.0704,0.0405,0.0073,用数组保存完全三叉堆，如果父节点的下标是k，那么三个子节点的下标分别是？
Apr 17 2022 10:09:31,84,5,17,8,0.5,0.964,0.914,0.932,5,1,0.0359,0.0858,0.0678,-0.0319,-0.0033,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
Apr 18 2022 11:47:02,111,150,420,200,0.48,0.93,0.856,0.938,4,1,0.0699,0.1438,0.0622,0.0078,0.001,简述霍夫曼树（Huffman Tree）的定义。
Apr 18 2022 11:49:11,42,17,61,32,0.53,0.961,0.915,0.965,5,1,0.0385,0.0852,0.0345,0.004,0.0003,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
Apr 19 2022 11:41:26,56,178,639,322,0.5,0.942,0.928,0.928,5,1,0.0578,0.0725,0.0725,-0.0147,-0.0019,简述插入排序中将某元素往前插入到适当位置的方式。 （利用交换两元素的位置的操作）
Apr 19 2022 11:55:45,29,163,592,395,0.67,0.944,0.941,0.966,5,1,0.0561,0.0594,0.0343,0.0218,0.002,简述算法复杂度符号~的定义： f(N) ~ g(N)，即 [.] 。
Apr 24 2022 08:41:55,115,151,401,191,0.48,0.921,0.851,0.942,3,1,0.0789,0.1492,0.0581,0.0208,0.0028,简述红黑树的rotateLeft操作。
Apr 24 2022 08:49:13,103,162,15,3,0.21,0.912,0.841,0.944,2,0,0.9118,0.8407,0.9436,-0.0318,-0.059,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
Apr 24 2022 08:49:52,58,185,687,187,0.27,0.937,0.922,0.922,5,1,0.0628,0.078,0.078,-0.0152,-0.0021,进行双路的Bottom-up merge sort，则每次进行的合并操作的两个子数组的长度是？（从第一次循环开始列出.)
Apr 25 2022 14:51:46,84,8,29,20,0.68,0.971,0.917,0.935,5,1,0.0291,0.0827,0.0654,-0.0363,-0.0034,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
Apr 26 2022 11:17:35,27,177,661,616,0.93,0.917,0.904,0.987,5,1,0.0826,0.0956,0.0126,0.07,0.0067,2-sum：给一个数组，找到其中所有和为0的序对，简述在线性时间内完成的思路。
Apr 27 2022 11:56:39,103,3,8,8,1.03,0.98,0.736,0.943,5,1,0.0204,0.2643,0.0569,-0.0365,-0.0028,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
Apr 27 2022 11:56:56,90,165,622,232,0.37,0.915,0.84,0.943,5,1,0.0849,0.1605,0.0568,0.028,0.004,简述一棵二叉搜索树（Binary Search Tree）的定义。
Apr 29 2022 19:06:10,122,165,622,296,0.48,0.91,0.837,0.947,5,1,0.0901,0.1632,0.0531,0.0369,0.0053,简述无向图中某顶点v的度的定义。
Apr 29 2022 19:11:51,77,190,703,333,0.47,0.897,0.816,0.945,5,1,0.1032,0.1844,0.0552,0.0479,0.0076,medians of medians算法在quick select算法中的用途是？
May 01 2022 21:02:43,88,182,677,244,0.36,0.896,0.821,0.95,5,1,0.1042,0.1792,0.0502,0.054,0.0083,简述最大堆的sink操作。
May 01 2022 21:02:51,51,183,680,316,0.47,0.907,0.925,0.957,5,1,0.0931,0.0751,0.0427,0.0504,0.0068,归并排序（是/不是）原地排序算法。
May 01 2022 21:05:37,33,196,722,200,0.28,0.934,0.918,0.918,5,1,0.0661,0.0822,0.0822,-0.0161,-0.0024,简述算法复杂度符号big Theta的定义（利用其它算法复杂度符号）：. （Image #6: d:\supermemo\systems\algorithm\temp\PastedImage11552.jpg）
May 03 2022 16:19:41,128,93,348,88,0.25,0.948,0.815,0.815,5,1,0.0522,0.1852,0.1852,-0.133,-0.0316,红黑树（左倾的）中如何将值插入一个2-node？
May 04 2022 11:48:15,97,91,341,116,0.34,0.93,0.842,0.876,5,1,0.0699,0.1582,0.1241,-0.0542,-0.0105,简述2-3 tree进行删除最小值的操作的思路。
May 05 2022 09:36:34,103,8,25,18,0.73,0.93,0.909,0.928,5,1,0.0695,0.0908,0.0717,-0.0022,-0.0003,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
May 07 2022 11:02:16,131,145,554,193,0.35,0.933,0.859,0.962,5,1,0.0672,0.141,0.0378,0.0294,0.0031,红黑树（左倾的）中如何将值b插入一个3-node，并且b的值介于a和c？ 如图： Image #16: d:\supermemo\systems\algorithm\temp\PastedImage8255.jpg
May 07 2022 11:02:21,18,186,658,382,0.58,0.944,0.937,0.964,5,1,0.0559,0.0626,0.036,0.0199,0.0018,用数组实现循环队列的经典做法：维护两个指针： 1.front指针指向队列中第一个元素 2.tail指针指向 [.] 。
May 16 2022 12:01:56,84,21,79,54,0.68,0.955,0.89,0.96,5,1,0.045,0.1104,0.0401,0.0049,0.0004,用数组保存完全三叉堆，如果某个子节点的下标是k，那么父节点的下标是？
May 18 2022 13:42:03,107,81,303,96,0.32,0.972,0.879,0.879,5,1,0.0284,0.1211,0.1211,-0.0926,-0.0138,简述算法中有向无环图的拓扑序列的定义。
May 20 2022 10:41:45,42,32,120,70,0.59,0.967,0.92,0.936,5,1,0.0325,0.0804,0.0636,-0.0311,-0.003,利用插入排序排序数组a (exch交换两个元素的位置，less比较两个元素的大小）: . for(int i=0;i<a.length; i++){    for (int j=i; [.] ; j--){        exch(a_j_j-1);    }}
May 23 2022 09:43:56,116,180,671,328,0.49,0.924,0.858,0.964,5,1,0.0763,0.1416,0.0358,0.0405,0.0045,简述二叉树的前序(Pre-order)访问的定义。
May 23 2022 09:46:14,103,18,62,25,0.4,0.955,0.879,0.921,5,1,0.0454,0.1214,0.0791,-0.0337,-0.0042,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
May 26 2022 11:26:24,73,184,644,443,0.69,0.908,0.872,0.981,5,1,0.0915,0.1284,0.0192,0.0724,0.008,证明：任何基于比较的排序算法至少会进行N lgN次比较。  假设待排序数组中没有重复的值，构造一颗比较树。 则该比较树的叶子节点的数目是 N! 则比较的次数大约是 [.]。
May 27 2022 11:00:04,93,170,638,235,0.37,0.949,0.926,0.926,5,1,0.051,0.0736,0.0736,-0.0226,-0.0028,简述如何获取二叉搜索树中最大的节点。
May 31 2022 12:02:53,9,198,728,190,0.26,0.906,0.703,0.809,5,1,0.0944,0.2965,0.1905,-0.0961,-0.0274,int[] a; for (int i = 0; i < 10; i++) a[i] = i * i;
Jun 01 2022 15:02:21,129,156,413,319,0.77,0.947,0.931,0.969,4,1,0.0532,0.0687,0.0312,0.022,0.0019,红黑树（左倾的）中如何将值c插入一个3-node，并且c比a和b都要大？. 如图：. MjAyMS0xMS0wNy0xNF8zNl81Mg==
Jun 08 2022 12:39:40,99,129,477,565,1.18,0.973,0.933,0.99,5,1,0.0272,0.0668,0.0102,0.017,0.0006,2-3 search trees（2-3 搜索树）有两种节点，（1）包含1个值的节点有2个子节点 （2）包含2个值的节点有[.]个子节点
Jun 08 2022 12:41:22,79,148,514,369,0.72,0.97,0.944,0.971,5,1,0.0302,0.0557,0.0287,0.0015,0.0001,简述最大堆的定义。
Jun 08 2022 12:43:11,15,232,15,4,0.27,0.886,0.897,0.987,2,0,0.8857,0.8968,0.9867,-0.1011,-0.1892,在java的类定义public class FixedCapacityStack<Item>中. a = new Item[cap];. 需要被写成. a = (Item[]) new Object[cap];. 的原因是？
Jun 12 2022 15:03:47,57,186,690,439,0.64,0.958,0.941,0.97,5,1,0.0415,0.0592,0.0303,0.0112,0.0008,归并排序中对 [lo.hi] 的部分进行分割为两部分后分别排序，如果mid = lo + (hi - lo)/2_ 那么分割为哪两部分（尽量使得两部分一样长）？
Jun 12 2022 15:52:27,15,4,10,13,1.35,0.973,0.647,0.929,5,1,0.0271,0.3529,0.0708,-0.0438,-0.0043,在java的类定义public class FixedCapacityStack<Item>中. a = new Item[cap];. 需要被写成. a = (Item[]) new Object[cap];. 的原因是？
Jun 13 2022 11:27:06,112,206,753,295,0.39,0.898,0.805,0.955,5,1,0.1017,0.1946,0.0452,0.0564,0.0083,简述如何从一些带权的节点中构造一颗霍夫曼树(Huffman Tree).
Jun 13 2022 11:27:18,14,228,779,418,0.54,0.913,0.905,0.953,5,1,0.0871,0.0949,0.047,0.0402,0.0054,java中为了将基础值类型作为泛型参数时的便利性（自动将基础类型和其对应的引用类型转换），提供了什么样的功能？
Jun 15 2022 11:05:15,124,207,15,3,0.23,0.898,0.805,0.957,2,0,0.8977,0.8046,0.9569,-0.0592,-0.1097,通常将树定义为 [.] 图。
Jun 17 2022 10:08:30,103,25,90,44,0.49,0.975,0.925,0.974,5,1,0.0253,0.0747,0.0262,-0.0009,0.0000,简述如何将某个值插入到2-3 search trees（2-3搜索树）中根节点的3-node上。
Jun 18 2022 16:55:53,124,3,8,9,1.13,0.98,0.711,0.944,5,1,0.0203,0.2895,0.0561,-0.0357,-0.0027,通常将树定义为 [.] 图。
Jun 18 2022 16:56:47,59,205,750,410,0.55,0.943,0.932,0.966,5,1,0.0573,0.068,0.0344,0.0229,0.0021,归并排序的合并操作在什么情况下是可以被省略的。
Jun 22 2022 20:11:50,32,110,428,174,0.41,0.946,0.909,0.909,5,1,0.0542,0.0912,0.0912,-0.037,-0.0054,简述算法复杂度符号big Omega的定义（利用其它算法复杂度符号）：. （Image #4: d:\supermemo\systems\algorithm\temp\PastedImage19239.jpg）
Jun 25 2022 10:24:41,15,13,39,24,0.62,0.909,0.881,0.915,5,1,0.0907,0.1185,0.0855,0.0053,0.0009,在java的类定义public class FixedCapacityStack<Item>中. a = new Item[cap];. 需要被写成. a = (Item[]) new Object[cap];. 的原因是？
Jun 26 2022 12:18:04,114,209,763,292,0.38,0.918,0.901,0.96,5,1,0.0819,0.0989,0.0396,0.0423,0.0051,基数排序的LSD(Most Significant Digit)法是指？
Jun 26 2022 12:19:06,100,212,772,301,0.39,0.913,0.839,0.965,5,1,0.087,0.161,0.0345,0.0524,0.0064,算法中一颗树（tree）是平衡的（balanced）是指什么？
Jun 27 2022 10:07:55,124,9,28,13,0.45,0.922,0.905,0.938,5,1,0.0778,0.095,0.0623,0.0156,0.0022,通常将树定义为 [.] 图。
Jun 27 2022 10:08:11,117,201,738,383,0.52,0.934,0.912,0.964,5,1,0.0657,0.0881,0.0356,0.0301,0.003,简述二叉树的后序（Post-order）访问的定义。
Jul 01 2022 09:23:12,3,246,873,268,0.31,0.938,0.911,0.911,5,1,0.0621,0.0887,0.0887,-0.0266,-0.004,page rank算法中，如果用N表示node的数量，d代表用户从某页面继续点击链接的概率系数（如0.85)_S代表所有链接到该页面的页面的page rank值/该页面所有的链接数的和，那么该页面page rank的更新值是？
Jul 01 2022 09:23:46,20,112,436,139,0.32,0.972,0.88,0.88,5,1,0.028,0.1196,0.1196,-0.0916,-0.0135,用数组实现循环队列的经典做法：front指针指向队列第一个元素，tail指针指向队列最后一个元素的后一个位置，length代表数组的长度。. 则判断队列是否为空的表达式为 [.] 。
